/* eslint-disable @typescript-eslint/ban-ts-comment */
/* eslint-disable @typescript-eslint/no-explicit-any */
// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import * as React from "react";

export const Index: Record<string, any> = {
  index: {
    name: "index",
    description: "",
    type: "registry:style",
    dependencies: ["class-variance-authority", "lucide-react", "uilab-core"],
    registryDependencies: ["utils"],
    files: [],
    component: null,
    categories: undefined,
    meta: undefined,
  },
  style: {
    name: "style",
    description: "",
    type: "registry:style",
    dependencies: ["class-variance-authority", "lucide-react", "uilab-core"],
    registryDependencies: ["utils"],
    files: [],
    component: null,
    categories: undefined,
    meta: undefined,
  },
  "currency-input": {
    name: "currency-input",
    description: "Input for currencies :)",
    type: "registry:component",
    dependencies: ["react-hook-form", "react-number-format", "uilab-core"],
    registryDependencies: undefined,
    files: [
      {
        path: "registry/classic/ui/currency-input.tsx",
        type: "registry:component",
        target: "",
        content:
          'import { BanknoteIcon } from "lucide-react";\nimport { Controller, useFormContext } from "react-hook-form";\nimport { NumericFormat } from "react-number-format";\nimport {\n  Field,\n  FieldError,\n  FieldLabel,\n  InputGroup,\n  InputGroupAddon,\n  InputGroupInput,\n  cn,\n} from "uilab-core";\nimport type { InputAttributes } from "react-number-format";\n\nexport function CurrencyInputField({\n  name,\n  placeholder,\n  label,\n  labelOnClick,\n  labelClassName = "",\n  labelIcon,\n  value,\n  onValueChange,\n  ...props\n}: Omit<InputAttributes, "type"> & {\n  name: string;\n  label?: string;\n  labelOnClick?: (event: any) => void;\n  labelClassName?: string;\n  labelIcon?: React.ReactNode;\n  value?: number | string;\n  onValueChange?: (values: {\n    value: string;\n    floatValue: number | undefined;\n    formattedValue: string;\n  }) => void;\n}) {\n  const form = useFormContext();\n\n  return (\n    <Controller\n      control={form.control}\n      name={name}\n      render={({ field, fieldState }) => {\n        return (\n          <Field\n            data-invalid={fieldState.invalid}\n            className={cn("w-full", props.className)}\n          >\n            <FieldLabel\n              className={labelClassName}\n              onClick={labelOnClick && labelOnClick}\n            >\n              {labelIcon && labelIcon}\n              {label || "Amount"}\n            </FieldLabel>\n            <InputGroup>\n              <InputGroupAddon>\n                <BanknoteIcon />\n              </InputGroupAddon>\n              <NumericFormat\n                {...props}\n                aria-invalid={fieldState.invalid}\n                placeholder={placeholder ?? label ?? ""}\n                customInput={InputGroupInput}\n                value={field.value ?? ""}\n                onValueChange={(values) => {\n                  field.onChange(\n                    values.floatValue === undefined ? null : values.floatValue,\n                  );\n                  if (onValueChange) onValueChange(values);\n                }}\n                valueIsNumericString={true}\n                thousandSeparator\n              />\n            </InputGroup>\n            {fieldState.invalid && <FieldError errors={[fieldState.error]} />}\n          </Field>\n        );\n      }}\n    />\n  );\n}\n',
      },
    ],
    component: React.lazy(async () => {
      const mod = await import("@/registry/classic/ui/currency-input.tsx");
      const exportName =
        Object.keys(mod).find(
          (key) =>
            typeof mod[key] === "function" || typeof mod[key] === "object",
        ) || item.name;
      return { default: mod.default || mod[exportName] };
    }),
    categories: undefined,
    meta: undefined,
  },
  confirmation: {
    name: "confirmation",
    description: "",
    type: "registry:block",
    dependencies: ["lucide-react", "uilab-core"],
    registryDependencies: undefined,
    files: [
      {
        path: "registry/classic/blocks/confirmation.tsx",
        type: "registry:component",
        target: "components/confirmation.tsx",
        content:
          'import * as React from "react";\nimport {\n  Button,\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from "uilab-core";\n\nexport type ContextType = {\n  showDialog: (options: ConfirmationOptions) => void;\n  hideDialog: () => void;\n};\n\nexport type ConfirmationOptions = {\n  title: string;\n  description: string;\n  confirmText?: string;\n  cancelText?: string;\n  onConfirm?: () => void;\n  onCancel?: () => void;\n};\n\nexport const ConfirmationContext = React.createContext<ContextType>(\n  {} as ContextType,\n);\n\nexport const useConfirmation = () => {\n  const context = React.useContext(ConfirmationContext);\n  if (!context) {\n    throw new Error(\n      "useConfirmation must be used within a ConfirmationProvider",\n    );\n  }\n  return context;\n};\n\nexport function ConfirmationProvider({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  const [open, setOpen] = React.useState(false);\n  const [dialogOptions, setDialogOptions] = React.useState<ConfirmationOptions>(\n    {\n      title: "",\n      description: "",\n    },\n  );\n\n  const showDialog = React.useCallback((options: ConfirmationOptions) => {\n    setDialogOptions(options);\n    setOpen(true);\n  }, []);\n\n  const hideDialog = React.useCallback(() => setOpen(false), []);\n\n  const handleConfirm = () => {\n    dialogOptions.onConfirm?.();\n    hideDialog();\n  };\n\n  const handleCancel = () => {\n    dialogOptions.onCancel?.();\n    hideDialog();\n  };\n\n  return (\n    <ConfirmationContext.Provider value={{ showDialog, hideDialog }}>\n      {children}\n      <Dialog open={open} onOpenChange={setOpen}>\n        <DialogContent>\n          <DialogHeader>\n            <DialogTitle>{dialogOptions.title}</DialogTitle>\n            <DialogDescription>{dialogOptions.description}</DialogDescription>\n          </DialogHeader>\n          <DialogFooter>\n            <Button variant="outline" onClick={handleCancel}>\n              {dialogOptions.cancelText || "Cancel"}\n            </Button>\n            <Button onClick={handleConfirm}>\n              {dialogOptions.confirmText || "Confirm"}\n            </Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n    </ConfirmationContext.Provider>\n  );\n}\n',
      },
    ],
    component: React.lazy(async () => {
      const mod = await import("@/registry/classic/blocks/confirmation.tsx");
      const exportName =
        Object.keys(mod).find(
          (key) =>
            typeof mod[key] === "function" || typeof mod[key] === "object",
        ) || item.name;
      return { default: mod.default || mod[exportName] };
    }),
    categories: ["dialog"],
    meta: undefined,
  },
  "data-table": {
    name: "data-table",
    description: "",
    type: "registry:block",
    dependencies: ["@tanstack/react-table", "lucide-react", "uilab-core"],
    registryDependencies: undefined,
    files: [
      {
        path: "registry/classic/blocks/data-table/advanced.tsx",
        type: "registry:component",
        target: "components/data-table/advanced.tsx",
        content:
          '"use client";\n\nimport * as React from "react";\nimport {\n  flexRender,\n  getCoreRowModel,\n  useReactTable,\n} from "@tanstack/react-table";\nimport type { PaginationOptions, TableMeta } from "@tanstack/react-table";\nimport { RefreshCcwIcon } from "lucide-react";\nimport {\n  Button,\n  cn,\n  Skeleton,\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableHeader,\n  TableRow,\n} from "uilab-core";\nimport type { DataColumn, DataPaginationState } from ".";\nimport Pagination from "./pagination";\n\ntype Props = {\n  /**\n   * Made to be fit with Pocket Pageable content response.\n   */\n  data: unknown[];\n  /**\n   * Collection of column definitions with\n   * [Tanstack Table](https://tanstack.com/table/latest/docs/api/core/column-def) standard\n   */\n  columns: DataColumn<any>[];\n  /**\n   * Default column options to use for all column defs supplied to the table.\n   */\n  defaultColumn?: DataColumn<any> | undefined;\n  /**\n   * Component will render loader skeleton if `true`. Should be provided from `useQuery` from [Tanstack Query](https://tanstack.com/query/v4/docs/framework/react/reference/useQuery)\n   */\n  isFetching: boolean;\n  /**\n   * You have to define TableCell in your column for more complex use cases\n   */\n  isCustomCell?: boolean;\n  /**\n   * State of pagination to keep track. On tanstack table, `manualPagination` is `true`, so you can update the state whenever you call an api.\n   */\n  pagination?: DataPaginationState;\n  paginationTotalText?: (total: string | number) => string;\n  paginationPageText?: (\n    current: string | number,\n    total: string | number,\n  ) => string;\n  paginationRowsText?: (rows: string | number) => string;\n  /**\n   * Necessary for rendering `Pagination` component to keep track.\n   */\n  paginationOptions?: Pick<\n    PaginationOptions,\n    "onPaginationChange" | "rowCount" | "pageCount"\n  >;\n  /**\n   * Refresh button text\n   */\n  refreshText?: string;\n  /**\n   * No results text\n   */\n  noResultsText?: string;\n  /**\n   * Element provided will be attached to the header\'s left side\n   */\n  leftHeader?: React.ReactNode;\n  /**\n   * Element provided will be attached to the header\'s right side\n   */\n  rightHeader?: React.ReactNode;\n  /**\n   * Additional data or method needed for the table\n   */\n  meta?: TableMeta<any>;\n  /**\n   * Border around the table\n   */\n  border?: boolean;\n  /**\n   * Optional if you want an action button that needs to reload api calls.\n   * Requires `isFetching` field and `refetch` function\n   * QOL component\n   */\n  refetch?: () => void;\n};\n\n/**\n * Advanced data tables that needs complex features such as Pagination, Filters, Column Hiding etc\n */\nexport function AdvancedDataTable({\n  data,\n  columns,\n  defaultColumn,\n  isFetching,\n  isCustomCell,\n  pagination,\n  paginationTotalText,\n  paginationPageText,\n  paginationRowsText,\n  paginationOptions = {},\n  refreshText = "Refresh",\n  noResultsText = "No results",\n  leftHeader,\n  rightHeader,\n  border = true,\n  meta,\n  refetch,\n}: Props) {\n  const table = useReactTable({\n    data: data || [],\n    columns,\n    defaultColumn,\n    getCoreRowModel: getCoreRowModel(),\n    manualPagination: true,\n    ...paginationOptions,\n    initialState: { pagination },\n    meta,\n  });\n\n  const renderHeaders = React.useCallback(\n    () =>\n      table.getHeaderGroups().map((headerGroup) => (\n        <TableRow key={headerGroup.id}>\n          {headerGroup.headers.map((header) => (\n            <TableHead\n              className={header.id === "action" ? "text-right" : ""}\n              key={header.id}\n            >\n              {header.isPlaceholder\n                ? null\n                : flexRender(\n                    header.column.columnDef.header,\n                    header.getContext(),\n                  )}\n            </TableHead>\n          ))}\n        </TableRow>\n      )),\n    [table],\n  );\n\n  return (\n    <div className="flex w-full flex-col gap-4">\n      <div className="flex w-full items-center justify-between">\n        <div className="flex items-center gap-2">\n          {leftHeader && leftHeader}\n        </div>\n        <div className="flex items-center justify-end gap-2">\n          {rightHeader && rightHeader}\n          {refetch && (\n            <Button variant="outline" onClick={refetch} disabled={isFetching}>\n              <RefreshCcwIcon /> {refreshText}\n            </Button>\n          )}\n        </div>\n      </div>\n      {isFetching ? (\n        <div className="flex w-full flex-col gap-2">\n          <Skeleton className="h-7 w-full" />\n          <Skeleton className="h-7 w-3/4" />\n          <Skeleton className="h-7 w-1/2" />\n        </div>\n      ) : (\n        <>\n          <div className={cn("rounded-lg", border && "border")}>\n            <Table>\n              <TableHeader>{renderHeaders()}</TableHeader>\n              <TableBody>\n                {table.getRowModel().rows?.length ? (\n                  table.getRowModel().rows.map((row) => (\n                    <TableRow\n                      key={row.id}\n                      className={cn(\n                        row.id === "actions" && "flex flex-row-reverse",\n                      )}\n                      data-state={row.getIsSelected() && "selected"}\n                    >\n                      {row.getVisibleCells().map((cell) => {\n                        const render = flexRender(\n                          cell.column.columnDef.cell,\n                          cell.getContext(),\n                        );\n\n                        return isCustomCell ? (\n                          render\n                        ) : (\n                          <TableCell\n                            className={cn(\n                              cell.column.id === "actions" &&\n                                "flex flex-row-reverse",\n                            )}\n                            key={cell.id}\n                          >\n                            {render}\n                          </TableCell>\n                        );\n                      })}\n                    </TableRow>\n                  ))\n                ) : (\n                  <TableRow>\n                    <TableCell\n                      colSpan={columns.length}\n                      className="h-24 text-center"\n                    >\n                      {noResultsText}\n                    </TableCell>\n                  </TableRow>\n                )}\n              </TableBody>\n            </Table>\n          </div>\n          {pagination && (\n            <Pagination\n              totalText={paginationTotalText}\n              pageText={paginationPageText}\n              rowsText={paginationRowsText}\n              table={table}\n              state={pagination}\n            />\n          )}\n        </>\n      )}\n    </div>\n  );\n}\n',
      },
      {
        path: "registry/classic/blocks/data-table/basic.tsx",
        type: "registry:component",
        target: "components/data-table/basic.tsx",
        content:
          '"use client";\n\nimport * as React from "react";\nimport {\n  flexRender,\n  getCoreRowModel,\n  useReactTable,\n  type TableMeta,\n} from "@tanstack/react-table";\nimport {\n  cn,\n  Skeleton,\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableHeader,\n  TableRow,\n} from "uilab-core";\nimport type { DataColumn } from ".";\n\ntype Props = {\n  /**\n   * Content to display\n   */\n  data: Array<any>;\n  /**\n   * Collection of column definitions with\n   * [Tanstack Table](https://tanstack.com/table/latest/docs/api/core/column-def) standard\n   */\n  columns: DataColumn<any>[];\n  /**\n   * Default column options to use for all column defs supplied to the table.\n   */\n  defaultColumn?: DataColumn<any> | undefined;\n  /**\n   * Border around the table\n   */\n  border?: boolean;\n  /**\n   * No Results text\n   */\n  noResultsText?: string;\n  /**\n   * Additional data or method needed for the table\n   */\n  meta?: TableMeta<any>;\n  /**\n   * Component will render loader skeleton if `true`. Should be provided from `useQuery` from [Tanstack Query](https://tanstack.com/query/v4/docs/framework/react/reference/useQuery)\n   */\n  isFetching?: boolean;\n  /**\n   * You have to define TableCell in your column for more complex use cases\n   */\n  isCustomCell?: boolean;\n};\n\nexport function BasicDataTable({\n  data,\n  columns,\n  defaultColumn,\n  border = true,\n  noResultsText = "No results",\n  meta,\n  isFetching,\n  isCustomCell,\n}: Props) {\n  const table = useReactTable({\n    data: data || [],\n    columns,\n    defaultColumn,\n    meta,\n    getCoreRowModel: getCoreRowModel(),\n  });\n\n  const renderHeaders = React.useCallback(\n    () =>\n      table.getHeaderGroups().map((headerGroup) => (\n        <TableRow key={headerGroup.id}>\n          {headerGroup.headers.map((header) => (\n            <TableHead\n              className={header.id === "action" ? "text-right" : ""}\n              key={header.id}\n            >\n              {header.isPlaceholder\n                ? null\n                : flexRender(\n                    header.column.columnDef.header,\n                    header.getContext(),\n                  )}\n            </TableHead>\n          ))}\n        </TableRow>\n      )),\n    [table],\n  );\n\n  if (isFetching) {\n    return (\n      <div className="flex w-full flex-col gap-2">\n        <Skeleton className="h-7 w-full" />\n        <Skeleton className="h-7 w-3/4" />\n        <Skeleton className="h-7 w-1/2" />\n      </div>\n    );\n  }\n\n  // Did not use `useReactTable` properties as it is broken\n  return (\n    <div className="w-full">\n      <div className={cn("mb-2 rounded-lg", border && "border")}>\n        <Table>\n          <TableHeader>{renderHeaders()}</TableHeader>\n          <TableBody>\n            {table.getRowModel().rows?.length ? (\n              table.getRowModel().rows.map((row) => (\n                <TableRow\n                  key={row.id}\n                  data-state={row.getIsSelected() && "selected"}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    const render = flexRender(\n                      cell.column.columnDef.cell,\n                      cell.getContext(),\n                    );\n\n                    return isCustomCell ? (\n                      render\n                    ) : (\n                      <TableCell\n                        className={cn(\n                          cell.column.id === "actions" &&\n                            "flex flex-row-reverse",\n                        )}\n                        key={cell.id}\n                      >\n                        {render}\n                      </TableCell>\n                    );\n                  })}\n                </TableRow>\n              ))\n            ) : (\n              <TableRow>\n                <TableCell\n                  colSpan={columns.length}\n                  className="h-24 text-center"\n                >\n                  {noResultsText}\n                </TableCell>\n              </TableRow>\n            )}\n          </TableBody>\n        </Table>\n      </div>\n    </div>\n  );\n}\n',
      },
      {
        path: "registry/classic/blocks/data-table/filter-popover.tsx",
        type: "registry:component",
        target: "components/data-table/filter-popover.tsx",
        content:
          '"use client";\n\nimport * as React from "react";\nimport { FilterIcon } from "lucide-react";\nimport { Button, Popover, PopoverContent, PopoverTrigger } from "uilab-core";\n\ntype Props = {\n  /**\n   * Number of filters that is currently applied\n   * use `calculateAppliedFilters` function for ease of use\n   */\n  applied?: number;\n  applyText?: string;\n  clearText?: string;\n  filterText?: string;\n  filterAppliedText?: (applied: number) => string;\n  children?: React.ReactNode;\n  onSubmit?: () => Promise<void>;\n  onReset?: () => any;\n};\n\nexport function FilterPopover({\n  applied,\n  applyText = "Apply",\n  clearText = "Clear",\n  filterText = "Filter",\n  filterAppliedText = (applied: number) => `${applied} filter applied`,\n  children,\n  onSubmit,\n  onReset,\n}: Props) {\n  const [open, setOpen] = React.useState<boolean>(false);\n\n  const handleSubmit = () => {\n    if (onSubmit) onSubmit();\n    setOpen(false);\n  };\n\n  const handleClear = () => {\n    if (onReset) onReset();\n    setOpen(false);\n  };\n\n  return (\n    <Popover open={open} onOpenChange={setOpen}>\n      <PopoverTrigger asChild>\n        <Button variant={applied !== 0 ? "secondary" : "outline"}>\n          <FilterIcon />\n          {applied !== 0 ? filterAppliedText(applied) : filterText}\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent align="start" className="w-xs space-y-3">\n        <div className="grid w-full grid-cols-1 gap-3">{children}</div>\n        <div className="flex flex-row-reverse gap-2">\n          <Button type="button" onClick={handleSubmit}>\n            {applyText}\n          </Button>\n          <Button type="button" variant="outline" onClick={handleClear}>\n            {clearText}\n          </Button>\n        </div>\n      </PopoverContent>\n    </Popover>\n  );\n}\n',
      },
      {
        path: "registry/classic/blocks/data-table/merged-cell.tsx",
        type: "registry:component",
        target: "components/data-table/merged-cell.tsx",
        content:
          '"use client";\n\nimport * as React from "react";\nimport { CellContext } from "@tanstack/react-table";\nimport { cn, TableCell } from "uilab-core";\n\ntype Props = {\n  context: CellContext<any, unknown>;\n  border?: boolean;\n} & React.ComponentPropsWithoutRef<"div">;\n\n/**\n * In order to use this, you have to set `isCustomCell` to `true` in any form of table block component\n */\nexport function MergedCell({\n  context,\n  className,\n  children,\n  border = true,\n}: Props) {\n  const { row, table, column } = context;\n  const cell = row.original[column.id];\n  const rows = table.getRowModel().rows;\n  const rowIndex = row.index;\n\n  // Count how many rows have the same category starting from this row\n  let rowSpan = 1;\n  if (rowIndex === 0 || rows[rowIndex - 1].original[column.id] !== cell) {\n    for (let i = rowIndex + 1; i < rows.length; i++) {\n      if (rows[i].original[column.id] === cell) {\n        rowSpan++;\n      } else {\n        break;\n      }\n    }\n\n    return (\n      <TableCell\n        rowSpan={rowSpan}\n        className={cn(className, border && "border")}\n      >\n        {children}\n      </TableCell>\n    );\n  }\n\n  return null;\n}\n',
      },
      {
        path: "registry/classic/blocks/data-table/pagination.tsx",
        type: "registry:component",
        target: "components/data-table/pagination.tsx",
        content:
          '"use client";\n\nimport * as React from "react";\nimport { ChevronDownIcon } from "lucide-react";\nimport {\n  Button,\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuRadioGroup,\n  DropdownMenuRadioItem,\n  DropdownMenuTrigger,\n  Pagination,\n  PaginationContent,\n  PaginationNext,\n  PaginationPrevious,\n} from "uilab-core";\nimport type { DataPaginationState, DataTable } from ".";\n\ntype Props = {\n  table: DataTable<unknown>;\n  state: DataPaginationState;\n  totalText?: (total: string | number) => string;\n  pageText?: (current: string | number, total: string | number) => string;\n  rowsText?: (rows: string | number) => string;\n};\n\nexport default React.memo(function TablePagination({\n  table,\n  state,\n  totalText = (total) => `Total of ${total} rows`,\n  pageText = (current, total) => `Page ${current}/${total}`,\n  rowsText = (rows) => `${rows} rows`,\n}: Props) {\n  // Tanstack methods are acting weird. I am actively working on it but for now this will do\n  const canPreviousPage = React.useCallback(\n    (): boolean => state.pageIndex > 0,\n    [state],\n  );\n  const canNextPage = React.useCallback(\n    (): boolean => state.pageIndex < table.getPageCount() - 1,\n    [state, table],\n  );\n\n  return (\n    <Pagination>\n      <PaginationContent className="w-full justify-between gap-6">\n        <p className="text-muted-foreground text-sm">\n          {totalText(table.getRowCount() || "")}\n        </p>\n        <div className="flex justify-center gap-6">\n          <DropdownMenu>\n            <DropdownMenuTrigger asChild>\n              <Button variant="outline">\n                {rowsText(state.pageSize)}\n                <ChevronDownIcon className="stroke-muted-foreground" />\n              </Button>\n            </DropdownMenuTrigger>\n            <DropdownMenuContent>\n              <DropdownMenuRadioGroup\n                value={state.pageSize.toString()}\n                onValueChange={(value: string) =>\n                  table.setPageSize(parseInt(value) || 20)\n                }\n              >\n                <DropdownMenuRadioItem value="10">\n                  {rowsText(10)}\n                </DropdownMenuRadioItem>\n                <DropdownMenuRadioItem value="25">\n                  {rowsText(25)}\n                </DropdownMenuRadioItem>\n                <DropdownMenuRadioItem value="50">\n                  {rowsText(50)}\n                </DropdownMenuRadioItem>\n              </DropdownMenuRadioGroup>\n            </DropdownMenuContent>\n          </DropdownMenu>\n          <div className="flex items-center justify-center gap-2 text-sm">\n            <span>\n              {pageText(\n                state.pageIndex + 1,\n                (table.getPageCount() || "0").toLocaleString(),\n              )}\n            </span>\n          </div>\n          <div className="flex items-center gap-1 text-sm">\n            <PaginationPrevious\n              size="icon"\n              onClick={() => table.previousPage()}\n              isActive={canPreviousPage()}\n            />\n            <PaginationNext\n              size="icon"\n              onClick={() => table.nextPage()}\n              isActive={canNextPage()}\n            />\n          </div>\n        </div>\n      </PaginationContent>\n    </Pagination>\n  );\n});\n',
      },
      {
        path: "registry/classic/blocks/data-table/index.tsx",
        type: "registry:component",
        target: "components/data-table/index.tsx",
        content:
          'import type {\n  ColumnDef as TanColumnDef,\n  PaginationState as TanPaginationState,\n  Table as TanTable,\n} from "@tanstack/react-table";\n\nexport type DataTable<T> = TanTable<T>;\nexport type DataColumn<T = unknown> = TanColumnDef<T>;\nexport type DataPaginationState = TanPaginationState;\n\nexport * from "./advanced";\nexport * from "./basic";\nexport * from "./filter-popover";\nexport * from "./merged-cell";\n',
      },
    ],
    component: React.lazy(async () => {
      const mod =
        await import("@/registry/classic/blocks/data-table/advanced.tsx");
      const exportName =
        Object.keys(mod).find(
          (key) =>
            typeof mod[key] === "function" || typeof mod[key] === "object",
        ) || item.name;
      return { default: mod.default || mod[exportName] };
    }),
    categories: ["data", "table"],
    meta: undefined,
  },
  "form-dialog": {
    name: "form-dialog",
    description: "",
    type: "registry:block",
    dependencies: ["react-hook-form", "lucide-react", "uilab-core"],
    registryDependencies: [
      "https://ailabmn.gitlab.io/frontend/uilab/registry/r/confirmation.json",
    ],
    files: [
      {
        path: "registry/classic/blocks/form-dialog.tsx",
        type: "registry:component",
        target: "components/form-dialog.tsx",
        content:
          '"use client";\n\nimport * as React from "react";\nimport { LoaderCircleIcon } from "lucide-react";\nimport { useFormContext } from "react-hook-form";\nimport {\n  Button,\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from "uilab-core";\nimport { useConfirmation } from "@/registry/classic/blocks/confirmation";\n\n/**\n * Dialog boilerplate for forms.\n * It has confirmation dialog and everything you need in one component\n */\nexport function FormDialog({\n  title = "",\n  description = "",\n  trigger,\n  className,\n  children,\n  open: propOpen = false,\n  setOpen: propSetOpen,\n  isPending = false,\n  shouldConfirmDiscard = true,\n  discardTitle = "Discard",\n  discardDescription = "Are you sure you want to discard? Your changes will not be saved!",\n  discardCancelText = "Cancel",\n  discardConfirmText = "Discard",\n  cancelText = "Cancel",\n  confirmText = "Confirm",\n  onSubmit,\n}: {\n  /** Display title on sheet header */\n  title: string;\n  /** Display description on sheet header */\n  description?: string;\n  /** JSX Element (preferable with forwardRef command) for opening the sheet */\n  trigger?: React.ReactNode;\n  open?: boolean;\n  setOpen?: React.Dispatch<React.SetStateAction<boolean>>;\n  className?: string;\n  children: any;\n  isPending?: boolean;\n  /** Shows a dialog when clicked out confirming the user to discard */\n  shouldConfirmDiscard?: boolean;\n  /** Discard confirmation\'s dialog title */\n  discardTitle?: string;\n  /** Discard confirmation\'s description title */\n  discardDescription?: string;\n  /** Discard confirmation\'s cancel text */\n  discardCancelText?: string;\n  /** Discard confirmation\'s confirm text */\n  discardConfirmText?: string;\n  cancelText?: string;\n  confirmText?: string;\n  /**\n   * This prop should be async function for ease of handling success and error.\n   * Component uses [@tanstack/react-query](https://tanstack.com/query/latest) so you don\'t have to pass down additional `useMutation` methods\n   */\n  onSubmit?: (values: any) => Promise<void>;\n}) {\n  const form = useFormContext();\n  const [open, setOpen] = React.useState<boolean>(propOpen);\n  const { showDialog } = useConfirmation();\n\n  const toggleSheet = React.useCallback(\n    (open: boolean) => {\n      setOpen(open);\n      form.reset();\n      form.clearErrors();\n    },\n    [form, setOpen],\n  );\n\n  const handleOnChange = React.useCallback(\n    (isOpen: boolean) => {\n      if (Object.keys(form.formState.dirtyFields).length !== 0 && open) {\n        if (shouldConfirmDiscard) {\n          showDialog({\n            title: discardTitle,\n            description: discardDescription,\n            confirmText: discardConfirmText,\n            cancelText: discardCancelText,\n            onConfirm: () => toggleSheet(isOpen),\n          });\n        } else {\n          toggleSheet(isOpen);\n        }\n      } else {\n        toggleSheet(isOpen);\n      }\n    },\n    [form, open, showDialog, toggleSheet, shouldConfirmDiscard],\n  );\n\n  const handleSubmit = async (values: any) => {\n    if (onSubmit) {\n      await onSubmit(values).then(() => toggleSheet(false));\n    }\n  };\n\n  React.useEffect(() => propSetOpen && propSetOpen(open), [propSetOpen, open]);\n  React.useEffect(() => setOpen(propOpen), [propOpen]);\n\n  return (\n    <Dialog open={open} onOpenChange={handleOnChange}>\n      {trigger}\n      <DialogContent className={className}>\n        <DialogHeader>\n          <DialogTitle> {title} </DialogTitle>\n          <DialogDescription> {description} </DialogDescription>\n        </DialogHeader>\n        <form className="space-y-4" onSubmit={form.handleSubmit(handleSubmit)}>\n          {children}\n          <button type="submit" className="hidden" />\n        </form>\n        <DialogFooter>\n          <Button\n            variant="outline"\n            type="button"\n            disabled={isPending}\n            onClick={(event) => {\n              event.preventDefault();\n              handleOnChange(false);\n            }}\n          >\n            {cancelText}\n          </Button>\n          <Button\n            type="button"\n            disabled={isPending}\n            onClick={form.handleSubmit(handleSubmit)}\n          >\n            {isPending && <LoaderCircleIcon className="animate-spin" />}\n            {confirmText}\n          </Button>\n        </DialogFooter>\n      </DialogContent>\n    </Dialog>\n  );\n}\n',
      },
    ],
    component: React.lazy(async () => {
      const mod = await import("@/registry/classic/blocks/form-dialog.tsx");
      const exportName =
        Object.keys(mod).find(
          (key) =>
            typeof mod[key] === "function" || typeof mod[key] === "object",
        ) || item.name;
      return { default: mod.default || mod[exportName] };
    }),
    categories: ["dialog", "form"],
    meta: undefined,
  },
  "form-sheet": {
    name: "form-sheet",
    description: "",
    type: "registry:block",
    dependencies: ["react-hook-form", "lucide-react", "uilab-core"],
    registryDependencies: [
      "https://ailabmn.gitlab.io/frontend/uilab/registry/r/confirmation.json",
    ],
    files: [
      {
        path: "registry/classic/blocks/form-sheet.tsx",
        type: "registry:component",
        target: "components/form-sheet.tsx",
        content:
          'import * as React from "react";\nimport { useFormContext } from "react-hook-form";\nimport { LoaderCircleIcon } from "lucide-react";\nimport {\n  Button,\n  Sheet,\n  SheetContent,\n  SheetDescription,\n  SheetFooter,\n  SheetHeader,\n  SheetTitle,\n  SheetTrigger,\n} from "uilab-core";\nimport { useConfirmation } from "@/registry/classic/blocks/confirmation";\n\n/**\n * Sheet boilerplate for forms.\n * It has confirmation dialog and everything you need in one component\n */\nexport function FormSheet({\n  title,\n  description = "",\n  trigger,\n  className,\n  children,\n  open: propOpen = false,\n  setOpen: propSetOpen,\n  isPending = false,\n  shouldConfirmDiscard = true,\n  discardTitle = "Discard",\n  discardDescription = "Are you sure you want to discard? Your changes will not be saved!",\n  discardCancelText = "Cancel",\n  discardConfirmText = "Discard",\n  cancelText = "Cancel",\n  confirmText = "Confirm",\n  onSubmit,\n}: {\n  /**\n   * Display title on sheet header\n   */\n  title: string;\n  /**\n   * Display description on sheet header\n   */\n  description?: string;\n  /**\n   * JSX Element (preferable with forwardRef command) for opening the sheet\n   */\n  trigger?: React.ReactNode;\n  open?: boolean;\n  setOpen?: React.Dispatch<React.SetStateAction<boolean>>;\n  className?: string;\n  children: any;\n  isPending?: boolean;\n  /** Shows a dialog when clicked out confirming the user to discard */\n  shouldConfirmDiscard?: boolean;\n  /** Discard confirmation\'s dialog title */\n  discardTitle?: string;\n  /** Discard confirmation\'s description title */\n  discardDescription?: string;\n  /** Discard confirmation\'s cancel text */\n  discardCancelText?: string;\n  /** Discard confirmation\'s confirm text */\n  discardConfirmText?: string;\n  cancelText?: string;\n  confirmText?: string;\n  /**\n   * This prop should be async function for ease of handling success and error.\n   * Component uses [@tanstack/react-query](https://tanstack.com/query/latest) so you don\'t have to pass down additional `useMutation` methods\n   */\n  onSubmit?: (values: any) => Promise<void>;\n}) {\n  const form = useFormContext();\n  const [open, setOpen] = React.useState<boolean>(propOpen);\n  const { showDialog } = useConfirmation();\n\n  const toggleSheet = React.useCallback(\n    (open: boolean) => {\n      setOpen(open);\n      form.reset();\n      form.clearErrors();\n    },\n    [form, setOpen],\n  );\n\n  const handleOnChange = React.useCallback(\n    (isOpen: boolean) => {\n      if (Object.keys(form.formState.dirtyFields).length !== 0 && open) {\n        if (shouldConfirmDiscard) {\n          showDialog({\n            title: discardTitle,\n            description: discardDescription,\n            confirmText: discardConfirmText,\n            cancelText: discardCancelText,\n            onConfirm: () => toggleSheet(isOpen),\n          });\n        } else {\n          toggleSheet(isOpen);\n        }\n      } else {\n        toggleSheet(isOpen);\n      }\n    },\n    [form, open, showDialog, toggleSheet, shouldConfirmDiscard],\n  );\n\n  const handleSubmit = async (values: any) => {\n    if (onSubmit) {\n      await onSubmit(values).then(() => toggleSheet(false));\n    }\n  };\n\n  React.useEffect(() => propSetOpen && propSetOpen(open), [propSetOpen, open]);\n  React.useEffect(() => setOpen(propOpen), [propOpen]);\n\n  return (\n    <Sheet open={open} onOpenChange={handleOnChange}>\n      <SheetTrigger asChild>{trigger}</SheetTrigger>\n      <SheetContent side="right" className={className}>\n        <SheetHeader>\n          <SheetTitle> {title} </SheetTitle>\n          <SheetDescription> {description} </SheetDescription>\n        </SheetHeader>\n        <div className="grid flex-1 auto-rows-min gap-4 overflow-y-auto px-4">\n          {children}\n        </div>\n        <SheetFooter>\n          <Button\n            type="button"\n            disabled={isPending}\n            onClick={form.handleSubmit(handleSubmit)}\n          >\n            {isPending && <LoaderCircleIcon className="animate-spin" />}\n            {confirmText}\n          </Button>\n          <Button\n            variant="outline"\n            type="button"\n            disabled={isPending}\n            onClick={(event) => {\n              event.preventDefault();\n              handleOnChange(false);\n            }}\n          >\n            {cancelText}\n          </Button>\n        </SheetFooter>\n      </SheetContent>\n    </Sheet>\n  );\n}\n',
      },
    ],
    component: React.lazy(async () => {
      const mod = await import("@/registry/classic/blocks/form-sheet.tsx");
      const exportName =
        Object.keys(mod).find(
          (key) =>
            typeof mod[key] === "function" || typeof mod[key] === "object",
        ) || item.name;
      return { default: mod.default || mod[exportName] };
    }),
    categories: ["sheet", "form"],
    meta: undefined,
  },
  sonner: {
    name: "sonner",
    description: "",
    type: "registry:block",
    dependencies: ["uilab-core", "lucide-react", "next-themes"],
    registryDependencies: undefined,
    files: [
      {
        path: "registry/classic/blocks/sonner.tsx",
        type: "registry:component",
        target: "components/sonner.tsx",
        content:
          '"use client";\n\nimport {\n  CircleCheckIcon,\n  InfoIcon,\n  Loader2Icon,\n  OctagonXIcon,\n  TriangleAlertIcon,\n} from "lucide-react";\nimport { useTheme } from "next-themes";\nimport { Toaster as Sonner, type ToasterProps } from "sonner";\n\nconst Toaster = ({ ...props }: ToasterProps) => {\n  const { theme = "system" } = useTheme();\n\n  return (\n    <Sonner\n      theme={theme as ToasterProps["theme"]}\n      className="toaster group"\n      icons={{\n        success: <CircleCheckIcon className="size-4" />,\n        info: <InfoIcon className="size-4" />,\n        warning: <TriangleAlertIcon className="size-4" />,\n        error: <OctagonXIcon className="size-4" />,\n        loading: <Loader2Icon className="size-4 animate-spin" />,\n      }}\n      style={\n        {\n          "--normal-bg": "var(--popover)",\n          "--normal-text": "var(--popover-foreground)",\n          "--normal-border": "var(--border)",\n          "--border-radius": "var(--radius)",\n        } as React.CSSProperties\n      }\n      {...props}\n    />\n  );\n};\n\nexport { Toaster };\n',
      },
    ],
    component: React.lazy(async () => {
      const mod = await import("@/registry/classic/blocks/sonner.tsx");
      const exportName =
        Object.keys(mod).find(
          (key) =>
            typeof mod[key] === "function" || typeof mod[key] === "object",
        ) || item.name;
      return { default: mod.default || mod[exportName] };
    }),
    categories: ["toaster"],
    meta: undefined,
  },
  "confirmation-demo": {
    name: "confirmation-demo",
    description: "",
    type: "registry:example",
    dependencies: ["lucide-react", "uilab-core"],
    registryDependencies: undefined,
    files: [
      {
        path: "registry/classic/examples/confirmation-demo.tsx",
        type: "registry:example",
        target: "",
        content:
          'import { Button } from "uilab-core";\nimport {\n  ConfirmationProvider,\n  useConfirmation,\n} from "@/registry/classic/blocks/confirmation";\n\nfunction ConfirmationButton() {\n  const { showDialog } = useConfirmation();\n\n  return (\n    <Button\n      onClick={() =>\n        showDialog({\n          title: "Delete Item",\n          description:\n            "Are you sure you want to delete this item? This action cannot be undone.",\n          confirmText: "Delete",\n          cancelText: "Cancel",\n          onConfirm: () => {\n            alert("Item deleted");\n          },\n          onCancel: () => {\n            alert("Cancelled");\n          },\n        })\n      }\n    >\n      Delete Item\n    </Button>\n  );\n}\n\nexport default function ConfirmationDemo() {\n  return (\n    <ConfirmationProvider>\n      <ConfirmationButton />\n    </ConfirmationProvider>\n  );\n}\n',
      },
    ],
    component: React.lazy(async () => {
      const mod =
        await import("@/registry/classic/examples/confirmation-demo.tsx");
      const exportName =
        Object.keys(mod).find(
          (key) =>
            typeof mod[key] === "function" || typeof mod[key] === "object",
        ) || item.name;
      return { default: mod.default || mod[exportName] };
    }),
    categories: undefined,
    meta: undefined,
  },
  "sonner-demo": {
    name: "sonner-demo",
    description: "",
    type: "registry:example",
    dependencies: ["sonner", "next-themes", "uilab-core"],
    registryDependencies: undefined,
    files: [
      {
        path: "registry/classic/examples/sonner-demo.tsx",
        type: "registry:example",
        target: "",
        content:
          'import { Button } from "uilab-core";\nimport { toast } from "sonner";\n\nexport default function SonnerDemo() {\n  return (\n    <Button\n      onClick={() =>\n        toast.success("Data saved successfully!", {\n          description: "Your changes have been saved to the database.",\n          action: {\n            label: "Undo",\n            onClick: () => alert("Undo"),\n          },\n        })\n      }\n    >\n      Show Success Toast\n    </Button>\n  );\n}\n',
      },
    ],
    component: React.lazy(async () => {
      const mod = await import("@/registry/classic/examples/sonner-demo.tsx");
      const exportName =
        Object.keys(mod).find(
          (key) =>
            typeof mod[key] === "function" || typeof mod[key] === "object",
        ) || item.name;
      return { default: mod.default || mod[exportName] };
    }),
    categories: undefined,
    meta: undefined,
  },
};
